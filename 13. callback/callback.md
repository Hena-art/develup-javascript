자 오늘은 중요한 이야기를 좀 할 겁니다. 
아니 뭐 맨날 중요하다고 해요 할 수도 있는데, 아 진짜 오늘은 진짜 중요하긴 해요.
바로 이 callback 함수인데요,

이 callback 함수는 처음에 배울 때는 좀 아리까리 할 수  있겠지만 리액트를 비롯한 웹 개발을 하시는 분들이라면 절대 
피할 수 없는 너무 중요한 이야기입니다.

callback에 대한 이야기를 하기 전에 
함수의 실행 순서에 대한 이야기를 좀 해야 할 거 같아요.

## 동기 vs 비동기

우리 이런 코드가 있다고 가정해봅시다.
그리고 여기서, 함수가 사람이라고 한 번 가정해봅시다.

```
function a() {
    console.log("a 실행");
}

function b() {
    console.log("b 실행");
}

function c() {
    console.log("c 실행");
}

function d() {
    console.log("d 실행");
}

a();
b();
c();
d();
```

이런 상황이라면, 마치 a b c가 일렬로 줄을 선 경우로도 빗댈 수 잇겠죠.  
그렇게
a가 먼저 처리되고  
b가 먼저 처리되고  
마지막으로 c가 처리되는 양상으로 이 코드가 실행된다고 할 수 잇겠죠.

이렇듯, 일반적인 상황이라면, 위에서 아래로  
일반적으로는 a 다 끝났다는 전제 하에 b(); 실행될겁니다.
그쵸?

자 근데 여기서  

근데 b가 엄청 오래 걸린다고 가정해봅시다.  
예를 들어 b가 5초 뒤에 끝나는 함수라고 가정해보죠.  

이런 경우 어떻게 될까요?

```
function a() {
    console.log("a 실행");
}

function b() {
    console.log('오래 걸리는 b 실행');
}

function c() {
    console.log("c 실행");
}

a();
setTimeout(b, 3000);
c();
```

참고로 여기서 `setTimeout`은 
지정해준 특정 시간 이후에 어떤 함수나 코드를 실행하고 싶을 때 
쓰는 함수라고 보시면 됩니다

첫번째 인자에는 실행하고 시킬 대상을 적어주시면 되고, 
두번째 인자에는 밀리세컨드 단위로 몇 밀리세컨드 뒤에 첫번째 인자를 실행시킬지를 써주면 됩니다.

어쨌든 이렇게 코드를 실행하게 되면
`a- > c -> b `순으로 실행됩니다.

즉,
a();가 바로 답을 내놓을 수 없는 상황이 아니라면, 천년만년 기다리고 있지 않습니다.
실행 순서가 보장이 안되는 거죠.

이는 자바스크립트의 특성 때문입니다.

이런 특성을 처리 비동기 처리라고 합니다.
당연하게도 반대는 동기처리라고 부르고요.

이 비동기처리가 무엇인지, 그리고 동기처리가 무엇인지는
자바스크립트 뿐만 아니라 프로그래밍에서 너무 중요한 개념이기 때문에
꼭 제대로 알아주시면 좋을 거 같아요.

> 예시 : 페이스북 로딩화면

여담이지만 자바스크립트에서 비동기처리가 발전한 이유 : 본질적으로는 싱글 쓰레드라서 그렇지만 좀 기능적인 면에서의 원인을 따져보자면
웹이라서 그렇다. 여러 자원들이 동일한 시간에 오지만은 않는다


```
function a(callback) {
    console.log("a 실행 시작");
    
    setTimeout(function() {
        console.log('Works!');
    }, 3000)
    callback();
}

function b() {
    console.log("이제서야 b 실행");
}
```

### 콜백함수

근데 순서 보장되어야 하는 경우, 
어떤 함수가 실행되기 위해서는 반드시 이전 함수의 마무리가 보장되어야만 하는 경우
도 물론 있을 수 있지 않겠어요?

이럴 경우 사용할 수 잇는 게 콜백함수입니다.

callback : 영어로 뭐죠? : 다시 부른다. 이런 뜻이죠?

좀 이따 타이밍 맞춰서 오는 함수, 부르면 그 때 오는 함수가 콜백함수입니다.

만일 a라는 함수의 실행 뒤에 실행되어야 하는 b 함수가 있다면,
a함수가 이러는 거죠, 

> "야 b함수야, 일단 딴거 하고 있을게 내가 부르면 그 때 와."

그래서 콜백함수입니다.

### 콜백함수 만드는 방법

이 콜백함수는 나중에 부를 함수를 인자로 넣어줌으로서 실행 순서를 보장한다 
이렇게 할 수 있는 이유는 뭐라고 했죠?

> 이제는 계속말해서 지겨울 것 같아요. 자바스크립트에서 함수는 일급 객체니까 가능합니다.

이 콜백 함수의 동작 원리를 좀 더 정확히 말씀드리자면, 
먼저 실행될 함수에게 다음 실행될 함수를 인자로 전달해주고

먼저 실행될 함수 안에서 나중에 실행할 함수를 실행해주는 겁니다.

> 즉, 실행할 함수를 인자로 갖고 와서 
먼저 실행할 함수를 지지고 볶고 나서 특정 시점에 실행해주겠다
이런 말이죠.

예를 들어볼까요?

```
function a(callback) {
    setTimeout(function() {
        console.log("오래 걸리는 a 함수")
        callback();
    }, 2000);
}

function b() {
    console.log("b 함수 실행");
}

a(b);
```

여담이지만, 이 콜백함수는 특히 이벤트 처리 함수에서 많이 쓰입니다.
어떤 이벤트가 일어나면, 어떤 함수 실행시켜라! 하는 식의 논리에 많이 쓰이는 거죠.


## 콜백 지옥

근데 이러면, 눈치 빠른 분들은 이미 문제를 짐작할 수도 있겠지만, 이런 문제가 생길 수 있습니다.

```
a() b() c() d() 함수를 실행하고 싶은데 a는 5초 b는 4초 c는 3초 d는 2초 걸려 그럼 어떡하지?


function one() {
  setTimeout(function() {
    console.log('1. First thing setting up second thing');
    setTimeout(function() {
      console.log('2. Second thing setting up third thing');
      setTimeout(function() {
        console.log('3. Third thing setting up fourth thing');
        setTimeout(function() {
          console.log('4. Fourth thing');
        }, 5000);
      }, 4000);
    }, 3000);
  }, 2000);
};
```

이런 극악의 가독성 코드를 콜백 지옥이라고 부릅니다.

이에 대한 해결로 `promise~async` 개념이 ES6에 새롭게 등장했는데 이에 대해서는 시간 관계상 ES6 때 자세히 말씀드리도록 할게요.
